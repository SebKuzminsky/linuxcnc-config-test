#!/usr/bin/env python3

import argparse
import atexit
import threading
import pathlib
import queue
import signal
import subprocess
import sys
import time


def run(cmd):
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True
        )

    except subprocess.CalledProcessError as e:
        print(f"failed to run program:")
        print(f"    cmd: {cmd}")
        print(f"    returncode: {e.returncode}")
        print(f"    stdout: {e.stdout}")
        print(f"    stderr: {e.stderr}")
        raise e

    return result


class DetachedContainer():

    def __init__(self, docker_image, x_display_num):
        self.x_display_num = x_display_num
        vnc_port = 5900 + x_display_num
        result = run([
            "docker", "run",
                "--platform=linux/amd64",
                "--detach",
                "--rm",
                "--cpus=2",
                "--memory=1g",
                "--cap-add=IPC_LOCK",
                "--cap-add=IPC_OWNER",
                "--cap-add=SYS_ADMIN",
                f"--publish={vnc_port}:{vnc_port}",
                docker_image,
                "bash", "-c", f"Xvfb :{x_display_num} -screen 0 1600x1200x16 & x11vnc -display :{x_display_num} -N -forever"
        ])
        self.container = result.stdout.strip()
        atexit.register(self.kill_container)


    def kill_container(self):
        result = run(['docker', 'kill', self.container])
        atexit.unregister(self.kill_container)


    def run(self, cmd):
        if type(cmd) is str:
            real_cmd = [ 'bash', '-x', '-c', cmd ]
        else:
            real_cmd = cmd
        return run(["docker", "exec", self.container, *real_cmd])


    def cp(self, src, dest):
        # Don't use `check` here, because we don't want to throw if the
        # src file is missing.
        return subprocess.run(
            ['docker', 'cp', f'{self.container}:{src}', str(dest)],
            capture_output=True
        )



def worker_thread(thread_num, docker_image, quit_event, workq):
    while not quit_event.is_set():
        # Each config looks like:
        # '/usr/share/doc/linuxcnc/examples/sample-configs/sim/axis/anglejog/anglejog.ini'
        # The main thread signals "no more work" by queueing a config of None.
        sim_config = workq.get(block=True)
        if sim_config is None:
            return

        name_parts = sim_config.split('/')[8:]
        config_name = '/'.join(name_parts)
        config_filename = '_'.join(name_parts)

        results_dir = pathlib.Path('results') / config_filename
        if results_dir.exists():
            print(f"{sim_config} results already exist, skipping")
            continue

        results_dir.mkdir(parents=True, exist_ok=True)
        for old_file in results_dir.glob("*"):
            old_file.unlink()

        print(f"testing config '{config_name}'")

        x_display_num = 10 + thread_num
        c = DetachedContainer(docker_image, x_display_num)


        #
        # run linuxcnc in the container
        #

        linuxcnc_process = subprocess.Popen(
            [
                "docker", "exec", "--env", f"DISPLAY=:{x_display_num}", c.container,
                'bash', '-x', '-c', f'su --pty -c "linuxcnc {sim_config}" testrunner'
            ],
            stdin = subprocess.DEVNULL,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE,
            text = True
        )

        try:
            result = linuxcnc_process.wait(10)

            # the process died, that's bad
            print(f"*** {config_name} died!")
            with open(results_dir/"unexpected-death", "w") as f:
                print(f"{linuxcnc_process.returncode}", file=f)

        except subprocess.TimeoutExpired as e:
            # process still running, that's good!
            run(['vncsnapshot', f'localhost:{x_display_num}', f'{results_dir}/{config_filename}.jpg'])

            # kill linuxcnc, to try to capture its dying logs
            linuxcnc_process.send_signal(signal.SIGINT)
            try:
                result = linuxcnc_process.wait(5)
            except subprocess.TimeoutExpired as e:
                pass

        open(results_dir/"stdout", "w").write(linuxcnc_process.stdout.read())
        open(results_dir/"stderr", "w").write(linuxcnc_process.stderr.read())

        c.cp('/home/testrunner/qtvcp.log', results_dir)
        c.cp('/home/testrunner/qtdesigner.log', results_dir)

        c.kill_container()


description = "Run LinuxCNC sim configs and look for problems."
parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description=description)
parser.add_argument("--docker-image", "-i", type=str, help="Docker image to use.  Defaults to 'linuxcnc-config-test'.")
parser.add_argument("--num-threads", "-t", type=int, help="Number of simultaneous test threads to run.  Each one will run an instance of LinuxCNC in a separate container.  Each container is allocated 2 CPUs and 1 GB RAM.  Defaults to 10.")
args = parser.parse_args()

if args.docker_image is None:
    args.docker_image = 'linuxcnc-config-test'

if args.num_threads is None:
    args.num_threads = 10


print("listing available sim configs...")
c = DetachedContainer(args.docker_image, 1)
result = c.run('dpkg -L linuxcnc-uspace | grep "sample-configs/sim/.*\.ini"')
c.kill_container()
sim_configs = result.stdout.split('\n')
print(f"{len(sim_configs)} configs found")

quit_event = threading.Event()
workq = queue.Queue()

print(f"starting {args.num_threads} worker threads")
work_threads = []
for thread_num in range(0, args.num_threads):
    t = threading.Thread(target=worker_thread, args=[thread_num, args.docker_image, quit_event, workq])
    t.start()
    work_threads.append(t)

try:
    for sim_config in sim_configs:
        workq.put(sim_config)

    for t in work_threads:
        workq.put(None)

    for t in work_threads:
        t.join()

except KeyboardInterrupt as e:
    quit_event.set()

    for t in work_threads:
        t.join()
