#!/usr/bin/env python3

import argparse
import atexit
import pathlib
import signal
import subprocess
import sys
import time


def run(cmd):
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True
        )

    except subprocess.CalledProcessError as e:
        print(f"failed to run program:")
        print(f"    cmd: {cmd}")
        print(f"    returncode: {e.returncode}")
        print(f"    stdout: {e.stdout}")
        print(f"    stderr: {e.stderr}")
        raise e

    return result


class DetachedContainer():

    def __init__(self, x_display_num):
        self.x_display_num = x_display_num
        vnc_port = 5900 + x_display_num
        result = run([
            "docker", "run",
                "--platform=linux/amd64",
                "--detach",
                "--rm",
                "--cpus=2",
                "--cap-add=IPC_LOCK",
                "--cap-add=IPC_OWNER",
                "--cap-add=SYS_ADMIN",
                f"--publish={vnc_port}:{vnc_port}",
                "linuxcnc-config-test",
                "bash", "-c", f"Xvfb :{x_display_num} -screen 0 1600x1200x16 & x11vnc -display :{x_display_num} -N -forever"
        ])
        self.container = result.stdout.strip()
        atexit.register(self.kill_container)


    def kill_container(self):
        result = run(['docker', 'kill', self.container])
        atexit.unregister(self.kill_container)


    def run(self, cmd):
        if type(cmd) is str:
            real_cmd = [ 'bash', '-x', '-c', cmd ]
        else:
            real_cmd = cmd
        return run(["docker", "exec", self.container, *real_cmd])


c = DetachedContainer(1)

print("listing available sim configs...")
result = c.run('dpkg -L linuxcnc-uspace | grep "sample-configs/sim/.*\.ini"')
c.kill_container()

sim_configs = result.stdout.split('\n')
print(f"{len(sim_configs)} configs found")

for sim_config in sim_configs:
    # each config looks like '/usr/share/doc/linuxcnc/examples/sample-configs/sim/axis/anglejog/anglejog.ini'
    name_parts = sim_config.split('/')[8:]
    name = '_'.join(name_parts)

    results_dir = pathlib.Path('results') / name
    if results_dir.exists():
        continue

    results_dir.mkdir(parents=True, exist_ok=True)
    for old_file in results_dir.glob("*"):
        old_file.unlink()

    print(f"testing config '{'/'.join(name_parts)}'")

    x_display_num = 20
    c = DetachedContainer(x_display_num)


    #
    # run linuxcnc in the container
    #

    linuxcnc_process = subprocess.Popen(
        [
            "docker", "exec", "--env", f"DISPLAY=:{x_display_num}", c.container,
            'bash', '-x', '-c', f'su --pty -c "linuxcnc {sim_config}" testrunner'
        ],
        stdin = subprocess.DEVNULL,
        stdout = subprocess.PIPE,
        stderr = subprocess.PIPE,
        text = True
    )

    time.sleep(10)

    run(['vncsnapshot', f'localhost:{x_display_num}', f'{results_dir}/{name}.jpg'])

    r = linuxcnc_process.poll()
    if r is None:
        # process still running, that's good!
        linuxcnc_process.send_signal(signal.SIGINT)
        result = linuxcnc_process.wait(5)
    else:
        # the process died, that's surprising and noteworthy
        print("*** linuxcnc died!")
        with open(results_dir/"unexpected-death", "w") as f:
            print(f"{linuxcnc_process.returncode}", file=f)

    # The linuxcnc process may be dead now or it may be alive still,
    # in any case save its output and move on.

    open(results_dir/"stdout", "w").write(linuxcnc_process.stdout.read())
    open(results_dir/"stderr", "w").write(linuxcnc_process.stderr.read())

    c.kill_container()
